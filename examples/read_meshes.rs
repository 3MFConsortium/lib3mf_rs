/*++

Copyright (C) 2024 3MF Consortium (Original Author)

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.1-develop.

Abstract: This is an autogenerated Rust application that demonstrates the
 usage of the Rust bindings of the 3MF Library

Interface version: 2.5.0

*/

use std::env;
use std::ffi::{CStr, CString};
use std::fs::File;
use std::io::Read;
use std::ptr;

use lib3mf::{
    CBool, Lib3MF_MeshObject, Lib3MF_Model, Lib3MF_Object, Lib3MF_ObjectIterator,
    Lib3MF_Reader, Lib3MF_Resource, Lib3MF_ResourceIterator, Wrapper, sPosition, sTriangle,
};

#[derive(Debug)]
struct MeshData {
    name: String,
    vertices: Vec<[f32; 3]>,
    triangles: Vec<[u32; 3]>,
}

fn check(err: i32, context: &str) {
    if err != 0 {
        panic!("{} failed with error {}", context, err);
    }
}

fn get_string<F>(mut call: F) -> Result<String, i32>
where
    F: FnMut(u32, *mut u32, *mut i8) -> i32,
{
    let mut needed: u32 = 0;
    let err = call(0, &mut needed, ptr::null_mut());
    if err != 0 {
        return Err(err);
    }
    if needed == 0 {
        return Ok(String::new());
    }
    let mut buffer = vec![0u8; needed as usize];
    let err = call(needed, &mut needed, buffer.as_mut_ptr() as *mut i8);
    if err != 0 {
        return Err(err);
    }
    let s = unsafe { CStr::from_ptr(buffer.as_ptr() as *const i8) }
        .to_string_lossy()
        .into_owned();
    Ok(s)
}

fn print_version(wrapper: &Wrapper) {
    let (major, minor, micro) = wrapper.GetLibraryVersion().expect("version");
    print!("lib3mf version = {}.{}.{}", major, minor, micro);
    if let Ok((has_pre, pre)) = wrapper.GetPrereleaseInformation() {
        if has_pre {
            print!("-{}", pre);
        }
    }
    if let Ok((has_build, build)) = wrapper.GetBuildInformation() {
        if has_build {
            print!("+{}", build);
        }
    }
    println!();
}

fn open_model(path: &str, read_from_buffer: bool) -> (Wrapper, Lib3MF_Model, Option<Vec<u8>>) {
    let wrapper = Wrapper::new(None).expect("failed to load library");
    let api = wrapper.api();

    let mut model: Lib3MF_Model = ptr::null_mut();
    let err = unsafe { (api.lib3mf_createmodel)(&mut model) };
    check(err, "CreateModel");

    let mut reader: Lib3MF_Reader = ptr::null_mut();
    let ext = CString::new("3mf").expect("ext");
    let err = unsafe { (api.lib3mf_model_queryreader)(model, ext.as_ptr(), &mut reader) };
    check(err, "QueryReader");

    if read_from_buffer {
        let mut file = File::open(path).expect("open file");
        let mut data = Vec::new();
        file.read_to_end(&mut data).expect("read file");
        let err = unsafe { (api.lib3mf_reader_readfrombuffer)(reader, data.len() as u64, data.as_ptr()) };
        check(err, "ReadFromBuffer");
        (wrapper, model, Some(data))
    } else {
        let cpath = CString::new(path).expect("path");
        let err = unsafe { (api.lib3mf_reader_readfromfile)(reader, cpath.as_ptr()) };
        check(err, "ReadFromFile");
        (wrapper, model, None)
    }
}

fn mesh_from_object(api: &lib3mf::Api, model: Lib3MF_Model, obj: Lib3MF_Object) -> MeshData {
    let mut mesh: Lib3MF_MeshObject = ptr::null_mut();
    let mut res_id: u32 = 0;
    let err = unsafe { (api.lib3mf_resource_getresourceid)(obj as Lib3MF_Resource, &mut res_id) };
    check(err, "GetResourceID");

    let err = unsafe { (api.lib3mf_model_getmeshobjectbyid)(model, res_id, &mut mesh) };
    check(err, "GetMeshObjectByID");

    let name = get_string(|buflen, needed, buffer| unsafe {
        (api.lib3mf_object_getname)(mesh as Lib3MF_Object, buflen, needed, buffer)
    })
    .unwrap_or_else(|e| panic!("GetName failed with error {}", e));

    let mut vertex_count: u32 = 0;
    let err = unsafe { (api.lib3mf_meshobject_getvertexcount)(mesh, &mut vertex_count) };
    check(err, "GetVertexCount");

    let mut vertices = vec![sPosition { Coordinates: [0.0; 3] }; vertex_count as usize];
    let mut needed_vertices: u64 = 0;
    let err = unsafe {
        (api.lib3mf_meshobject_getvertices)(
            mesh,
            vertex_count as u64,
            &mut needed_vertices,
            vertices.as_mut_ptr(),
        )
    };
    check(err, "GetVertices");

    let mut triangle_count: u32 = 0;
    let err = unsafe { (api.lib3mf_meshobject_gettrianglecount)(mesh, &mut triangle_count) };
    check(err, "GetTriangleCount");

    let mut triangles = vec![sTriangle { Indices: [0; 3] }; triangle_count as usize];
    let mut needed_tris: u64 = 0;
    let err = unsafe {
        (api.lib3mf_meshobject_gettriangleindices)(
            mesh,
            triangle_count as u64,
            &mut needed_tris,
            triangles.as_mut_ptr(),
        )
    };
    check(err, "GetTriangleIndices");

    let verts = vertices
        .iter()
        .map(|v| [v.Coordinates[0], v.Coordinates[1], v.Coordinates[2]])
        .collect::<Vec<_>>();

    let tris = triangles
        .iter()
        .map(|t| [t.Indices[0], t.Indices[1], t.Indices[2]])
        .collect::<Vec<_>>();

    MeshData {
        name,
        vertices: verts,
        triangles: tris,
    }
}

fn load_meshes(path: &str, read_from_buffer: bool) -> Vec<MeshData> {
    println!("------------------------------------------------------------------");
    println!("3MF Read example (mesh extraction)");

    let (wrapper, model, data) = open_model(path, read_from_buffer);
    print_version(&wrapper);

    println!("------------------------------------------------------------------");

    let api = wrapper.api();
    let mut meshes = Vec::<MeshData>::new();

    let mut it: Lib3MF_ObjectIterator = ptr::null_mut();
    let err = unsafe { (api.lib3mf_model_getobjects)(model, &mut it) };
    check(err, "GetObjects");

    let mut has_next: CBool = 0;
    loop {
        let err = unsafe { (api.lib3mf_resourceiterator_movenext)(it as Lib3MF_ResourceIterator, &mut has_next) };
        check(err, "MoveNext");
        if has_next == 0 {
            break;
        }
        let mut obj: Lib3MF_Object = ptr::null_mut();
        let err = unsafe { (api.lib3mf_objectiterator_getcurrentobject)(it, &mut obj) };
        check(err, "GetCurrentObject");

        let mut is_mesh: CBool = 0;
        let err = unsafe { (api.lib3mf_object_ismeshobject)(obj, &mut is_mesh) };
        check(err, "IsMeshObject");
        if is_mesh != 0 {
            meshes.push(mesh_from_object(api, model, obj));
        }
    }

    if let Some(_data) = data {
        // Keep data alive until we are done with the model.
    }

    meshes
}

fn usage() {
    eprintln!("Usage: read_meshes [--buffer] model.3mf");
}

fn main() {
    let mut args = env::args().skip(1);
    let mut read_from_buffer = false;
    let mut path: Option<String> = None;

    while let Some(arg) = args.next() {
        if arg == "--buffer" {
            read_from_buffer = true;
        } else if arg.starts_with('-') {
            usage();
            return;
        } else {
            path = Some(arg);
        }
    }

    let path = match path {
        Some(p) => p,
        None => {
            usage();
            return;
        }
    };

    let meshes = load_meshes(&path, read_from_buffer);
    println!("Loaded {} mesh(es)", meshes.len());
    for (i, m) in meshes.iter().enumerate() {
        println!(
            "Mesh #{}: \"{}\" | vertices={} triangles={}",
            i + 1,
            m.name,
            m.vertices.len(),
            m.triangles.len()
        );
    }
}
